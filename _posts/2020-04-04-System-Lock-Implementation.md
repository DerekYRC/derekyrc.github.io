---
layout:     post
title:      从操作系统层面看锁的实现原理 
subtitle:   锁的实现原理
date:       2020-04-04
author:     Derek
header-img: img/post-bg-map.jpg 	# 这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								# 标签
    - 操作系统
    - 锁
---
锁是并发编程中保证线程安全的重要工具。多进程或多线程程序设计能提高资源的利用率从而提供机器的整体性能，但同时会带来线程安全的问题。协作的线程可能会共享一些彼此都能读写的公共存储区域，如内存和文件，对公共存储区域进行访问的程序片段我们称为临界区（critical section）。多线程对公共存储区域的操作的结果，取决于进程/线程运行的的精确时序，这被称为竞争条件（race condition）。为了避免竞争条件，需要安排同一时间只能有一个线程处于临界区中，达到线程安全的目的--这就是锁存在的意义，持有锁的线程才能进入临界区，其他线程自旋或阻塞等待锁的释放然后竞争获取锁。

锁的实现方案有多种，现在来看硬件支持的方案。
CPU提供了TSL（Test and Set Lock）指令：
> TSL RX,LOCK  ;RX：寄存器，LOCK：内存地址

它将内存地址LOCK（下称lock变量）存放的值读到寄存器RX中，然后在改内存地址中存一个非零值。该指令执行时，CPU将锁住内存总线，以禁止其他CPU访问内存，直至该指令执行结束，因此以上读写操作是原子性的。

解释了TSL指令的用法，现在用其构造锁。竞争锁时，读取lock变量的值到寄存器中，并将lock变量设为非零值，若寄存器值为零，说明其他线程没有持有该锁，因此本线程获得锁，拥有进入临界区的权限；否则若寄存器值不为零，说明其他线程持有该锁，可不断自旋尝试，直至成功。

竞争锁的过程简化如下：
```
enter_region:
	TSL REGISTER,LOCK 	;复制锁到寄存器并将锁设为1
	CMP REGISTER,#0 	;判断锁是否为零
	JNE enter_region	;锁不为零则自旋循环，直至成功
	RET 				;锁为零则说明竞争锁成功，返回进入临界区

```

释放锁很简单，只需将lock变量值设为零即可，指令简化如下：
```
leave_region:
	MOVE LOCK,#0	;锁值设为零
	RET 			;返回

```

除了TSL指令可以实现锁外还有XCHG指令。XCHG指令可以原子性地交换两个位置（如寄存器和内存地址上的值）的值。用XCHG实现锁的思路同上：
竞争锁的过程：
```
enter_region:
	MOVE REGISTER,#1	;设寄存器值为1
	XCHG REGISTER,LOCK 	;交换寄存器和锁变量的值
	CMP REGISTER,#0 	;判断锁是否为零
	JNE enter_region	;锁不为零则自旋循环，直至成功
	RET 				;锁为零则说明竞争锁成功，返回进入临界区

```

上述是自旋锁的实现原理，可见其在获取锁失败的时候会自旋不断循环重试，直至成功。在竞争不激烈的时候，重试次数较少时就能成功获取锁，当竞争激烈时，过多的线程自旋会占用CPU的时间，所以在竞争激烈的情况下，可以在获取锁失败时主动让出CPU时间片，待调度程序重新调度本线程运行时重试。思路如下：

竞争锁的过程：
```
enter_region:
	TSL REGISTER,LOCK 	;复制锁到寄存器并将锁设为1
	CMP REGISTER,#0 	;判断锁是否为零
	JZE ok				;竞争锁成功，返回
	call thread_yield	;竞争锁失败，主动让出CPU时间片
	JMP enter_region	;下次被调度时重试
ok: RET

```
